const filter = require('gulp-filter')
const fs = require('fs-extra')
const glob = require('glob')
const gutil = require('gulp-util')
const path = require('path')
const through = require('through2')

const comparison = require('../comparison')
const logger = require('../logger')

module.exports = (styleguide, gulp) => {
  styleguide.task.sketch = () => `styleguide:sketch`

  function getProjectRootPath () {
    return path.join(styleguide.path.build(), 'node_modules', styleguide.project.name())
  }

  function toHtml (file, encoding, callback) {
    const filePath = file.path
    const fileName = path.basename(filePath)

    if (fileName.slice(0, 1) !== '_') {
      try {
        const processed = comparison(styleguide, filePath)

        file.contents = Buffer.from(processed.html)
        file.path = gutil.replaceExtension(filePath, '.html')
        this.push(file)
      } catch (err) {
        logger.error(`${err.message} at [${filePath}]!`)
        if (!styleguide.isWatching()) {
          process.exit(1)
        }
      }
    }

    callback()
  }

  gulp.task(styleguide.task.sketch(), [ styleguide.task.clean() ], done => {
    glob.sync('**/*.json', {
      cwd: path.join(styleguide.path.root(), `sketch/export`),
      absolute: true
    })
      .forEach(sketchFile => {
        const styles = JSON.parse(fs.readFileSync(sketchFile, 'utf8')).styles

        if (!styles) return

        const lesshintOverrides = `hexNotation: false, spaceAroundComma: false, maxCharPerLine: false, singleLinePerProperty: false, newlineAfterBlock: false`
        let lessData = `// lesshint ${lesshintOverrides}\n/* This file was autogenerated by the Brightspot Express Sketch plugin. DO NOT edit this file directly. */\n\n`

        // Get the exported "colorStyles".
        const colorStyles = styles.filter(style => style._type === `colorStyle`).sort((a, b) => a.name > b.name)

        // Generate Less color mixins.
        colorStyles.forEach(colorStyle => {
          if (!colorStyle.color) return
          let cssProperty = ''

          colorStyle.lessMixin = `.sketch("${colorStyle.name}")`

          if (colorStyle.color.stops && colorStyle.color.stops.length) {
            colorStyle.color.stops.forEach(stop => {
              cssProperty += `rgba(${stop.red}, ${stop.green}, ${stop.blue}, ${stop.alpha}) ${stop.position}%,`
            })
          } else {
            cssProperty += `rgb(${colorStyle.color.red}, ${colorStyle.color.green}, ${colorStyle.color.blue});\n`
          }

          return cssProperty
        })

        // Get the exported "textStyles".
        const textStyles = styles.filter(style => style._type === `textStyle`).sort((a, b) => a.name > b.name)

        textStyles.forEach(textStyle => {
          // Determine which contrasting shade to use given the color's luminance.
          // credit: https://24ways.org/2010/calculating-color-contrast/
          if (textStyle.color) {
            const yiq = ((textStyle.color.red * 299) + (textStyle.color.green * 587) + (textStyle.color.blue * 114)) / 1000
            const contrast = (yiq >= 128) ? 'dark' : 'light'
            textStyle.contrast = contrast
          }

          if (textStyle.alignment) {
            textStyle.cssProps += `text-align: ${textStyle.alignment};`
          }

          textStyle.cssProps += `-webkit-font-smoothing: antialiased;`
          textStyle.cssProps += `-moz-osx-font-smoothing: grayscale;`

          // Format the CSS ruleset.
          let cssProperties = textStyle.cssProps
            .split(';').map(prop => {
              return `\n  ${prop.trim()}`
            }).join(';')

          // Generate the Less mixin.
          lessData += `\n.sketch(@textStyle) when (@textStyle = "${textStyle.name}") {\n  ${cssProperties.trim()}\n}\n`
        })

        // Get the unique font-families from the textStyles.
        const fontFamilies = [ ...new Set(textStyles.map(style => style.fontFamily)) ].sort()

        styleguide.sketch[`${path.parse(sketchFile).name}`] = {
          fontFamilies: fontFamilies,
          textStyles: textStyles
        }

        try {
          fs.mkdirsSync(path.join(getProjectRootPath(), `/styleguide/_sketch`, path.dirname(sketchFile).split(`/export/`).pop()))
          fs.writeFileSync(path.join(getProjectRootPath(), `/styleguide/_sketch`, gutil.replaceExtension(sketchFile, '.less').split(`/export/`).pop()), lessData)
        } catch (e) {
          logger.error(`Error writing file: ${gutil.replaceExtension(sketchFile, '.less')}`)
        }
      })

    const jsonFilter = filter(['**/*.json'], { restore: true })

    return gulp.src(path.join(styleguide.path.root(), 'sketch/export/**/*.{json,png}'))
      .pipe(jsonFilter)
      .pipe(through.obj(toHtml))
      .pipe(jsonFilter.restore)
      .pipe(gulp.dest(path.join(getProjectRootPath(), 'styleguide/_sketch')))
  })
}
