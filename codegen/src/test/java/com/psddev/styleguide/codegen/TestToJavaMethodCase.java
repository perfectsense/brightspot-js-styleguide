package com.psddev.styleguide.codegen;

import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.junit.Assert;
import org.junit.Test;

public class TestToJavaMethodCase {

    @Test
    public void testToJavaMethodCase() throws Exception {

        /*
         * First verify that we have a valid bean spec read method to property
         * descriptor name mappings in our example class. See comments in the
         * class below.
         */
        Map<String, Object> beanSpecMap = new LinkedHashMap<>();

        getBeanPropertyDescriptors(JavaBeanSpecExample.class).stream()
                // exclude the getClass() method
                .filter((prop) -> !"class".equals(prop.getName()))
                // ensure the read (getter) method is present
                .filter((prop) -> prop.getReadMethod() != null)
                // load the properties into a map.
                .collect(Collectors.toMap(
                        // key is the descriptor name
                        PropertyDescriptor::getName,
                        // value is the read method's value.
                        prop -> invoke(prop.getReadMethod(), new JavaBeanSpecExample()),
                        // merge function just keeps the original value
                        (m1, m2) -> m1,
                        // store them in the keyValues map
                        () -> beanSpecMap));

        for (Map.Entry<String, Object> entry : beanSpecMap.entrySet()) {
            Assert.assertEquals(entry.getKey(), entry.getValue());
        }

        /*
         * Next, verify that ViewClassStringUtils#toJavaMethodCase does the
         * correct inverse conversion of property descriptor name to read method.
         */

        // a map of bean spec property descriptor name to the expected read method name.
        // This map is used to verify that ViewClassStringUtils#toJavaMethodCase
        // API does the correct conversions.
        Map<String, String> inputOutputs = new LinkedHashMap<>();

        getBeanPropertyDescriptors(JavaBeanSpecExample.class).stream()
                // exclude the getClass() method
                .filter((prop) -> !"class".equals(prop.getName()))
                // ensure the read (getter) method is present
                .filter((prop) -> prop.getReadMethod() != null)
                // load the inputs and expected outputs into a map.
                .collect(Collectors.toMap(
                        // key is the descriptor name
                        PropertyDescriptor::getName,
                        // value is the read method's name.
                        prop -> prop.getReadMethod().getName(),
                        // merge function just keeps the original value
                        (m1, m2) -> m1,
                        // store them in the keyValues map
                        () -> inputOutputs));

        for (Map.Entry<String, String> entry : inputOutputs.entrySet()) {
            Assert.assertEquals(entry.getValue(), "get" + ViewClassStringUtils.toJavaMethodCase(entry.getKey()));
        }
    }

    /*
     * Each bean spec read method returns the expected property descriptor name
     * for itself. This serves as an example for the JSON field name to java
     * interface method mappings that should be generated by the view class
     * generator.
     */
    private static class JavaBeanSpecExample {

        public String getZ() {
            return "z";
        }

        public String getDD() {
            return "DD";
        }

        public String getDc() {
            return "dc";
        }

        public String getDC() {
            return "DC";
        }

        public String getdC() {
            return "dC";
        }

        public String getDCA() {
            return "DCA";
        }

        public String getDCa() {
            return "DCa";
        }

        public String getDca() {
            return "dca";
        }

        public String getA1() {
            return "a1";
        }

        public String getA1b2() {
            return "a1b2";
        }

        public String getA1B2() {
            return "a1B2";
        }

        public String getA1BC() {
            return "a1BC";
        }

        public String getA1Bc() {
            return "a1Bc";
        }

        public String getA_b_c() {
            return "a_b_c";
        }

        public String getaBc() {
            return "aBc";
        }

        public String getaBC() {
            return "aBC";
        }

        public String getAaBc() {
            return "aaBc";
        }

        public String getAaBC() {
            return "aaBC";
        }

        public String getFoo() {
            return "foo";
        }

        public String getFooBar() {
            return "fooBar";
        }

        public String getFoo_Bar() {
            return "foo_Bar";
        }

        public String get$foo() {
            return "$foo";
        }

        public String get_foo() {
            return "_foo";
        }

        public String get$foo$bar() {
            return "$foo$bar";
        }

        public String get_foo_bar() {
            return "_foo_bar";
        }

        public String get$Foo$Bar() {
            return "$Foo$Bar";
        }

        public String get_Foo_Bar() {
            return "_Foo_Bar";
        }
    }

    // Gets the list of bean property descriptors for the specified class.
    private static List<PropertyDescriptor> getBeanPropertyDescriptors(Class<?> viewClass) {
        try {
            return Arrays.asList(Introspector.getBeanInfo(viewClass).getPropertyDescriptors());
        } catch (IntrospectionException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    private static Object invoke(Method method, Object view) {

        try {
            method.setAccessible(true);
            return method.invoke(view);

        } catch (IllegalAccessException | InvocationTargetException e) {

            String message = "Failed to invoke method: " + method;

            Throwable cause = e.getCause();
            cause = cause != null ? cause : e;

            throw new RuntimeException(message, cause);
        }
    }
}
